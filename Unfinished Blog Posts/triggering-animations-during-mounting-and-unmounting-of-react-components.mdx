---
slug: animating-your-react-components-during-mounting-and-unmounting
date: '10 January, 2020'
dateForSorting: 2020-01-10T12:33:33.949Z
title: Animating your React Components during mounting and unmounting
tags:
  - react
excerpt: >-
  Learn how to trigger animations during the mounting and unmounting stages of
  your react component using React-transition-group
image: ''
---
- - -

layout: page-fullwidth
title: Animating your React Components during mounting and unmounting
categories:
	- React
tags:
	- Animations
header: no
breadcrumb: true
meta_description:  "Learn how to trigger animations during the mounting and unmounting stages of your react component using React-transition-group"
author: yusuff_faruq

- - -

Animations help improve the feel of a website and this leads to better user experience. We can use animations during different events: during page change, while scrolling and of course during mounting and un-mounting on components in component-based frameworks or libraries such as React.

In this article, you will learn how to trigger animations during the mounting and un-mounting stages of your React component using React Transition Group.

According to the React Transition Group Documentation, React Transition Group is not a library and I agree with this. It simply exposes transition stages, manages classes and performs other useful functions which make it easy to trigger animations during mounting and unmounting. This "pseudo-library" consists of 4 components, three of which we will use in this article.

Let's get started!

## The Transition Component

According to the documentation:

_"The Transition component lets you describe a transition from one component state to another over time with a simple declarative API. Most commonly it's used to animate the mounting and unmounting of a component, but can also be used to describe in-place transition states as well."_

You want to use this component when you need to animate the mounting and unmounting of a component using styling in JavaScript. If you want to use CSS styling, you should use the _CSSTransition_ component which we look into next.

Once again, according to the docs:

_"By default the Transition component does not alter the behavior of the component it renders, it only tracks "enter" and "exit" states for the components. It's up to you to give meaning and effect to those states."_

Now, we will demonstrate how the Transition Component tracks the different state of a component.

First, let's create a new React project. Once that is done, we'll need to install React Transition Group:
With npm

```bash
$ npm install react-transition-group --save
```

With yarn

```bash
$ yarn add react-transition-group
```

Now that you have it installed, we need to create a new component. I'll call mine **AComponent.** Note that I will be writing all my code in one file - _app.js_

Once you have your empty component ready, import the Transition component from react-transition-group.

```javascript
import { Transition } from "react-transition-group";
```

Now that you have it imported, we can now use it in our component. The Transition component takes a function as a child and this function returns whatever markup we want to apply animations to. The function also has an argument called _state_. This **state** argument tells us the present state of our component such as entering, entered, exiting and exited. Now that we understand that, let us write some code.

```jsx
const AComponent = ({ in: inProp }) => (
  <Transition in={inProp} timeout={500}>
    {state => (
      <div>
        I am {state}
      </div>
    )}
  </Transition>
); 
```

As you can see, the Transition component takes in two props - an **in** prop and a **timeout** prop. There are other props some of which we will look into later. For now, let's discuss these two props:

* The value of the **in** prop is a boolean (true or false). If the value is in, our component will enter the **entering** state; if it is false, our component will enter the **exited** state. We will set this using state soon.
* The **timeout** prop defines the duration for each transition. You can assign it just one value if you want to set the same duration for all transitions. By transitions, I mean **appear**, **enter**, and **exit**. You can also assign different time duration to each transition like this:

```jsx
timeout={{
 appear: 500,
 enter: 300,
 exit: 500,
}}
```

Now that we have written our component, let us use it in our App component. In our App component, we will create a button which will be used to toggle the value of the **in** prop between true and false. To do that, we will make use of the useState hook. First of all, we need to import the useState hook from React:

```javascript
import React, { useState } from "react";
```

Once that is done, let's create a new state:

```
const [entered, setEntered] = useState(false);
```

We can write our button element as follows:

```jsx
<button
  onClick={() => {
    setEntered(!entered);
  }}
>
  Toggle Entered
</button>
```

This button will toggle the value of the **in** prop.

Now let us use AComponent in our App component

```jsx
function App(){
  const [entered, setEntered] = useState(false);
  return (
    <div
>
      <AComponent in={entered} />
        <button
          onClick={() => {
            setEntered(!entered);
          }}
        >
          Toggle Entered
        </button>
    </div>
  );
}
```

Now, once you run your React app, you should see a text with "I am exited". This is because we set the initial value of our state variable, **entered**, to **false.** Clicking the button should change the text to "I am entering" and then to "I am entered". Clicking again should change the text to "I am exiting" and then to "I am exited". You should now understand how tracking state with the Transition component works. By now, you have probably noticed whenever a component exits, it doesn't unmount. You change this by adding the unmountOnExit prop to the Transition component like this:

```jsx
const AComponent = ({ in: inProp }) => (
  <Transition in={inProp} timeout={500} unmountOnExit>
    {state => (
      <div>
        I am {state}
      </div>
    )}
  </Transition>
); 
```

Now, the component should actually be unmounted upon reaching the "exited" stage. Since we now understand how tracking of state works, we should be able to apply styles during mounting and unmounting. Now let's make AComponent scale up in size in during mounting. We need to change the initial value of **entered** to _true_. We also need to define some default styles and set the different styles during each state of the component. First of all, let us define our default styles:

```javascript
const defaultStyle = {
  transition: `transform 200ms, opacity 200ms ease`,
  opacity: 1
};
```

Now let's define the different styles for each state:

```js
const transitionStyles = {
  entering: { transform: "scale(0.5)", opacity: 0 }, 
  entered: { transform: "scale(2.0)", opacity: 1},
  exiting: { opacity: 0 },
  exited: { opacity: 0 }
};
```

Normally, AComponent would move right into the **entered** state without passing through the entering state on first mount. To change that, we need to add a prop called **appear** to the Transition component used in AComponent. We also want to use a different time duration for each state. We'll set **appear** to 100ms and enter and exit to 300ms. Finally, we want to apply the default and transition styles to div element returned from the child function of the Transition Component. AComponent should look like this now:

```javascript
const AComponent = ({ in: inProp }) => (
  <Transition
    in={inProp}
    timeout={{
      appear: 100,   
      enter: 300,
      exit: 300
    }}
    appear
    unmountOnExit
  >
    {state => (
      <div
        style={{
          ...defaultStyle,
          ...transitionStyles[state]
        }}
      >
        I am {state}
      </div>
    )}
  </Transition>
);
```

Now when you run your app, the text should scale up in size during mounting and scale down before vanishing during unmounting with a nice transition.

## The CSSTransition Component

This transition is very similar to the Transition but it uses CSS transitions instead of JavaScript styles. With the CSSTransition, you have more control over the different states of your component.
